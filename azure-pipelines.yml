# to future maintainers   considering that this is an open-source project please be mindful of the fact that this file is PUBLIC
# to future maintainers   so any sensitive pieces of info (tokens, passwords, etc) should be stored in ENCRYPTED Azure DevOps pipeline variables
# to future maintainers
# to future maintainers   in the same vein of thought its important to always keep an eye on the pipelines trigger-settings for PR validation
# to future maintainers   to ensure that PR builds coming from people outside Laerdal fire if and only if a Laerdal dev has explicitly comments
# to future maintainers   on the PR with the following string [build]    if this string is not present the PR build should NOT fire

trigger:
  branches:
    include:
      - '*'
 
pool:
  name: 'Azure Pipelines'
  vmImage: 'macOS-12'

variables:
  - group: shared-variables  # needed for the github access token which is used to create new releases in github

  - name: 'Laerdal_Test_Results_Folderpath'
    value: '$(Build.Repository.LocalPath)/TestResults'

  - name: 'is_pr'
    ${{ if eq(variables.Build.Reason, 'PullRequest') }}:
      value: true
  - name: 'is_manual_build'
    ${{ if eq(variables.Build.Reason, 'Manual') }}:
      value: true
  - name: 'is_scheduled_build'
    ${{ if eq(variables.Build.Reason, 'Schedule') }}:
      value: true
  - name: 'is_triggered_from_another_build'
    ${{ if eq(variables.Build.Reason, 'BuildCompletion') }}:
      value: true
  - name: 'is_triggered_from_resource_trigger'
    ${{ if eq(variables.Build.Reason, 'ResourceTrigger') }}:
      value: true
  - name: 'is_triggered_from_central_branches'
    ${{ if in(variables.Build.SourceBranch, 'refs/heads/main', 'refs/heads/master', 'refs/heads/develop') }}:
      value: true
  - name: 'contains_build_keyword_in_commit_message'
    ${{ if contains(variables.Build.SourceVersionMessage, '[build]') }}:
      value: true
  - name: 'is_from_fork'
    ${{ if eq(variables.System.PullRequest.IsFork, 'True') }}:
      value: true

  - name: 'should_build'
    ${{     if    eq(variables.is_pr, true)                                      }}:
      value: 'Yes'
    ${{ elseif    eq(variables.is_manual_build, true)                            }}:
      value: 'Yes'
    ${{ elseif    eq(variables.is_scheduled_build, true)                         }}:
      value: 'Yes'
    ${{ elseif    eq(variables.is_triggered_from_another_build, true)            }}:
      value: 'Yes'
    ${{ elseif    eq(variables.is_triggered_from_resource_trigger, true)         }}:
      value: 'Yes'
    ${{ elseif    eq(variables.is_triggered_from_central_branches, true)         }}:
      value: 'Yes'
    ${{ elseif    eq(variables.contains_build_keyword_in_commit_message, true)   }}:
      value: 'Yes'
    ${{ else }}:
      value: 'No'
  
  # to future maintainers   keep this dead last and separate   this is a special case because we want to
  # to future maintainers   explicitly disable any and all activity related to 3rd party forks in github
  - name: 'should_build'
    ${{     if    eq(variables.is_from_fork, true)                               }}: 
      value: 'No'

resources:
  repositories:
    - repository: self
      type: git
      ref: refs/heads/develop

# to future maintainers    its vital to STOP the build from firing on PRs coming from forks because stuff like github usernames and access tokens can be easily
# to future maintainers    leaked by malevolent forkers (who can use a trivial .sh script to upload our secrets somewhere) and that would be a security issue
jobs:

  - job: 'Skip_Build'
    condition: eq(variables.should_build, 'No')
    displayName: "Should we auto-build? ... ${{ variables.should_build }} (is_pr=${{ variables.is_pr }}, is_manual_build=${{ variables.is_manual_build }}, is_scheduled_build=${{ variables.is_scheduled_build }}, is_triggered_from_another_build=${{ variables.is_triggered_from_another_build }}, is_triggered_from_resource_trigger=${{ variables.is_triggered_from_resource_trigger }}, is_triggered_from_central_branches=${{ variables.is_triggered_from_central_branches }}, contains_build_keyword_in_commit_message=${{ variables.contains_build_keyword_in_commit_message }}, is_from_fork=${{ variables.is_from_fork }}, Build.Reason=${{ variables.Build.Reason }}, Build.SourceBranch=${{ variables.Build.SourceBranch }}, Build.SourceVersionMessage=${{ variables.Build.SourceVersionMessage }}, System.PullRequest.IsFork=${{ variables.System.PullRequest.IsFork }})" 
    steps:
      - checkout: none # keep this
        displayName: '(Skipping checkout completely ...)'
      - script: 'echo "##vso[task.complete result=SucceededWithIssues;]Build skipped because this is a PR coming from a fork or because this is from a feature branch in which the latest commit message doesnt contain the keyword [build]"'
        displayName: '(Set Warning-Icon ...)'

  - job: 'Build'
    condition: eq(variables.should_build, 'Yes')
    displayName: 'Build Agent'
    steps:
      - checkout: self
        displayName: 'Checkout'
        clean: true
        fetchTags: false
        fetchDepth: 0
        persistCredentials: True
    
      - task: Bash@3
        displayName: 'Setup Build Environment for "Laerdal.McuMgr.Bindings"'
        inputs:
          targetType: filePath
          filePath: 'Laerdal.SetupBuildEnvironment.sh'
    
      - task: NuGetToolInstaller@1
        displayName: 'Install Nuget'
        inputs:
          checkLatest: true
    
      - script: 'mkdir "$(Build.ArtifactStagingDirectory)/Artifacts"'
        displayName: 'Create Directory "$(Build.ArtifactStagingDirectory)/Artifacts"'
    
      - task: NuGetCommand@2
        displayName: 'NuGet Sources Add (for Classic Xamarin)'
        inputs:
          command: 'custom'
          arguments: ' sources   Add   -Name     LocalNugets   -Source   "$(Build.ArtifactStagingDirectory)/Artifacts" '
    
      - task: DotNetCoreCLI@2
        displayName: 'NuGet Sources Add (for .Net6+)'
        inputs:
          command: 'custom'
          custom: 'nuget'
          arguments: ' add source "$(Build.ArtifactStagingDirectory)/Artifacts" '
    
      # notice that explicitly disabling parallelization via m:1 below is vital because if parallelization is enabled the ios and android
      # builds will fail with cryptic errors due to multiple target-frameworks are involved coupled with the custom build logic for native libs
      - task: DotNetCoreCLI@2
        displayName: 'Build .Net6+ Bindings and McuMgr itself and announce new release in GitHub (if needed)'
        inputs:
          command: 'custom'
          custom: 'msbuild'
          arguments: 'Laerdal.McuMgr.Builder.targets    -m:1   -p:Laerdal_Test_Results_Folderpath="$(Laerdal_Test_Results_Folderpath)"   -p:Laerdal_Github_Username="$(Github.ComponentsTeam.Username)"   -p:Laerdal_Github_Access_Token="$(Github.ComponentsTeam.AccessToken)"   -p:Laerdal_Repository="$(Repository.Path)"     -p:Laerdal_Source_Branch="$(Build.SourceBranch)"    -p:PackageOutputPath="$(Build.ArtifactStagingDirectory)/Artifacts/" '
    
      - task: PublishTestResults@2
        displayName: 'Publish Test Results'
        inputs:
          testRunTitle: 'McuMgr Test Suite (Platform-Agnostic)'
          mergeTestResults: true
          testResultsFiles: |
            $(Laerdal_Test_Results_Folderpath)/**/TEST-*.xml
            $(Laerdal_Test_Results_Folderpath)/**/TEST-*.trx
          testResultsFormat: 'XUnit'
          publishRunAttachments: true
          failTaskOnFailedTests: true
          failTaskOnMissingResultsFile: true
    
      # bare in mind that this task doesnt support wildcards
      - task: PublishBuildArtifacts@1
        inputs:
          ArtifactName: 'drop'
          PathtoPublish: '$(Build.ArtifactStagingDirectory)/Artifacts/'
          publishLocation: 'Container'
